import nhmfl
import pandas as pd
import numpy as np
import scipy

def integrate_bdot(bdot, area, dt):
    # integrate
    field = np.cumsum(np.asarray(bdot)/area*dt)
    # correct ending field to zero
    field -= field[-1] * np.asarray(list(range(len(field)))) / len(field)
    return field

# given a starting index i0, find range of contiguous elements
# of constant value before and after. returns (start,finish)
def contiguous_constant_interval(a, i0):
    value = a[i0]
    
    # search forward and backward
    start = i0
    finish = i0
    while a[start] == value:
        start -= 1
    while a[finish] == value:
        finish += 1
    return start+1,finish

# A segment is defined as a region where the sign of the field and the sign of Bdot are both constant.
# We identify a segment by passing a time value within that segment to pulse_segment(). It responds
# with time and field for that segment only.
def pulse_segment(time,field,t_in_segment):
    # determine where field is positive vs negative, and increasing vs decreasing
    field_pos = field >= 0
    bdot_pos = np.gradient(field) >= 0
    condition = field_pos.astype(int) + bdot_pos.astype(int)*2
    # list of conditions:
    # 0 : B<0, decreasing
    # 1 : B>=0, decreasing
    # 2 : B<0, increasing
    # 3 : B>=0, increasing
    
    # find index of the sample time provided within the segment
    i0 = np.searchsorted(time, t_in_segment)
    start,stop = contiguous_constant_interval(condition,i0)
    
    return time[start:stop],field[start:stop]

# for simple up/down pulses on typical magnets, it is possible to simplify the segmentation process
# for very short or long pulse lengths, it may be necessary to adjust holdoff
# e.g. 60 T long pulse or a sub-ms magnet
def split_pulse(time,field,holdoff=0.001):
    # first discover if pulse is positive or negative
    if abs(max(field)) > abs(min(field)):
        # positive polarity pulse
        imax = np.argmax(field)
        tmax = time[imax]
    else:
        imax = np.argmax(-field)
        tmax = time[imax]


    up = pulse_segment(time,field,tmax - holdoff)
    down = pulse_segment(time,field,tmax + holdoff)

    # returns time_u,field_u,time_d,field_d
    return up[0],up[1],down[0],down[1]

# Use for single-coil pulsed field experiments with crowbar diode.
# Callable object operates on a dictionary of keys as generated by nhmfl.log.Experiment.save()[0]
class PulseSplitterSimplex:
    def __init__(self,time_key,data_key):
        self.time_key = time_key
        self.data_key = data_key

    def __call__(self, s):
        tb=s['tb'] # time vs field
        bb=s['bb'] # field
        td=s[self.time_key] # time vs data
        dd=s[self.data_key] # data
        t_up,b_up,t_down,b_down = nhmfl.pulsed_field.split_pulse(tb,bb)

        blow,bhigh,dlow,dhigh = nhmfl.interpolation.domain_intersection_limits(t_up,td)
        b_up_cs = scipy.interpolate.interp1d(t_up[blow:bhigh], b_up[blow:bhigh], kind='linear')
        bd_up = b_up_cs(td[dlow+1:dhigh-2])
        dd_up = dd[dlow+1:dhigh-2]
        s[self.data_key+'_bup'] = bd_up
        s[self.data_key+'_up'] = dd_up

        blow,bhigh,dlow,dhigh = nhmfl.interpolation.domain_intersection_limits(t_down,td)
        b_dn_cs = scipy.interpolate.interp1d(t_down[blow:bhigh], b_down[blow:bhigh], kind='linear')
        bd_dn = b_dn_cs(td[dlow+1:dhigh-2])
        dd_dn = dd[dlow+1:dhigh-2]
        s[self.data_key+'_bdn'] = bd_dn
        s[self.data_key+'_dn'] = dd_dn
        
        # we don't yet spline into equally spaced B domain yet.
        return s

# Use for duplex/triplex magnets or LC ringdown experiments
# Callable object operates on a dictionary of keys as generated by nhmfl.log.Experiment.save()[0]
class PulseSegment:
    def __init__(self,time_key,data_key,t_in_segment,bout_key,dout_key):
        self.time_key=time_key
        self.data_key=data_key
        self.t_in_segment=t_in_segment
        self.bout_key=bout_key
        self.dout_key=dout_key
    def __call__(self, s):
        tb=s['tb'] # time vs field
        bb=s['bb'] # field
        td=s[self.time_key] # time vs data
        dd=s[self.data_key] # data
        t,b = nhmfl.pulsed_field.pulse_segment(tb,bb,self.t_in_segment)

        blow,bhigh,dlow,dhigh = nhmfl.interpolation.domain_intersection_limits(t,td)
        b_cs = scipy.interpolate.interp1d(t[blow:bhigh], b[blow:bhigh], kind='linear')
        bd = b_cs(td[dlow+1:dhigh-2])
        dd_out = dd[dlow+1:dhigh-2]
        s[self.bout_key] = bd
        s[self.dout_key] = dd_out
        
        # we don't yet spline into equally spaced B domain yet.
        return s
